<!DOCTYPE html>
<html>
<head>
    <title>Mobile Platform Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            touch-action: none;
            background-color: #000; /* Fallback if images don't load */
        }
        #gameCanvas {
            display: block;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
        }
        .touch-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
            border: 2px solid white;
            touch-action: manipulation;
            font-size: 24px;
            color: white;
            user-select: none;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="controls">
        <div>
            <button class="touch-btn" id="leftBtn">←</button>
            <button class="touch-btn" id="rightBtn">→</button>
        </div>
        <button class="touch-btn" id="jumpBtn">↑</button>
    </div>

<script>
// Debugging helper
console.log("Game script loading...");

// Canvas setup
const canvas = document.getElementById('gameCanvas');
const context = canvas.getContext('2d');

// Set canvas size to window size
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    console.log(`Canvas resized to ${canvas.width}x${canvas.height}`);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Game objects
let gameOver = false;
let assetsLoaded = 0;
const totalAssets = 4; // Update this if you add more assets

// Image loading with error handling
function loadImage(src, onLoad) {
    const img = new Image();
    img.onload = () => {
        console.log(`Loaded image: ${src}`);
        onLoad(img);
        assetsLoaded++;
        if (assetsLoaded === totalAssets) startGame();
    };
    img.onerror = () => {
        console.error(`Failed to load image: ${src}`);
        // Create a colored rectangle as fallback
        const fallback = document.createElement('canvas');
        fallback.width = 100;
        fallback.height = 100;
        const ctx = fallback.getContext('2d');
        ctx.fillStyle = src.includes('Player') ? 'blue' : 
                        src.includes('Enemy') ? 'red' :
                        src.includes('Background') ? 'lightblue' : 'green';
        ctx.fillRect(0, 0, 100, 100);
        onLoad(fallback);
        assetsLoaded++;
        if (assetsLoaded === totalAssets) startGame();
    };
    img.src = src;
    return img;
}

// Game assets
const backgroundImage = loadImage('Background.png', (img) => backgroundImage.img = img);
const gameOverImage = loadImage('GameOver.png', (img) => gameOverImage.img = img);
const lifeImage = loadImage('Live.png', (img) => lifeImage.img = img);

// Player setup
const player = {
    x: 50,
    y: 400,
    width: 100,
    height: 100,
    dx: 0,
    dy: 0,
    gravity: 0.5,
    jumpForce: 10,
    jumping: false,
    lives: 3,
    sprite: loadImage('Player.png', (img) => player.sprite = img)
};

// Enemy setup
const enemy = {
    x: 300,
    y: 400,
    width: 50,
    height: 50,
    dx: -2,
    dy: 0,
    gravity: 0.5,
    jumpForce: 10,
    jumping: false,
    rotation: 0,
    dead: false,
    sprite: loadImage('Enemy.png', (img) => enemy.sprite = img)
};

// Platform setup
const platform = {
    x: 0,
    y: canvas.height - 100,
    width: canvas.width,
    height: 50,
    color: '#0c0'
};

// Touch controls setup
function setupControls() {
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const jumpBtn = document.getElementById('jumpBtn');

    function handleButton(velocity) {
        player.dx = velocity;
    }

    leftBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleButton(-5);
    });
    leftBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (player.dx < 0) handleButton(0);
    });

    rightBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleButton(5);
    });
    rightBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (player.dx > 0) handleButton(0);
    });

    jumpBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!player.jumping) {
            player.dy = -player.jumpForce;
            player.jumping = true;
        }
    });

    console.log("Touch controls initialized");
}

// Drawing functions
function draw() {
    context.clearRect(0, 0, canvas.width, canvas.height);

    if (gameOver) {
        context.fillStyle = 'black';
        context.fillRect(0, 0, canvas.width, canvas.height);
        if (gameOverImage.img) {
            context.drawImage(gameOverImage.img, 0, 0, canvas.width, canvas.height);
        } else {
            context.fillStyle = 'white';
            context.font = '48px Arial';
            context.textAlign = 'center';
            context.fillText('GAME OVER', canvas.width/2, canvas.height/2);
        }
    } else {
        // Draw background
        if (backgroundImage.img) {
            context.drawImage(backgroundImage.img, 0, 0, canvas.width, canvas.height);
        } else {
            context.fillStyle = 'lightblue';
            context.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Draw lives
        for (let i = 0; i < player.lives; i++) {
            if (lifeImage.img) {
                context.drawImage(lifeImage.img, 10 + i * 30, 10, 20, 20);
            } else {
                context.fillStyle = 'red';
                context.fillRect(10 + i * 30, 10, 20, 20);
            }
        }

        // Draw player
        if (player.sprite) {
            context.drawImage(player.sprite, player.x, player.y, player.width, player.height);
        } else {
            context.fillStyle = 'blue';
            context.fillRect(player.x, player.y, player.width, player.height);
        }

        // Draw enemy if not dead
        if (!enemy.dead) {
            context.save();
            context.translate(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
            context.rotate(enemy.rotation);
            if (enemy.sprite) {
                context.drawImage(enemy.sprite, -enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
            } else {
                context.fillStyle = 'red';
                context.fillRect(-enemy.width/2, -enemy.height/2, enemy.width, enemy.height);
            }
            context.restore();
        }

        // Draw platform
        context.fillStyle = platform.color;
        context.fillRect(platform.x, platform.y, platform.width, platform.height);
    }
}

// Game logic
function update() {
    if (gameOver) return;

    // Player movement
    player.x += player.dx;
    player.y += player.dy;

    // Player-platform collision
    if (player.y + player.height > platform.y) {
        player.y = platform.y - player.height;
        player.jumping = false;
        player.dy = 0;
    } else {
        player.dy += player.gravity;
    }

    // Player boundaries
    player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
    player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));

    // Enemy movement
    if (!enemy.dead) {
        enemy.x += enemy.dx;
        if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) {
            enemy.dx *= -1;
            enemy.rotation += Math.PI;
        }

        // Player-enemy collision
        if (checkCollision(player, enemy)) {
            player.lives--;
            player.x = 50;
            player.y = 100;
            if (player.lives < 0) {
                gameOver = true;
                console.log("Game Over!");
            }
        }
    }

    draw();
    requestAnimationFrame(update);
}

function checkCollision(rect1, rect2) {
    return rect1.x < rect2.x + rect2.width &&
           rect1.x + rect1.width > rect2.x &&
           rect1.y < rect2.y + rect2.height &&
           rect1.y + rect1.height > rect2.y;
}

function startGame() {
    console.log("All assets loaded, starting game...");
    setupControls();
    platform.y = canvas.height - 100;
    platform.width = canvas.width;
    update();
}
</script>
</body>
</html>
